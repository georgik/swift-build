diff --git a/.gitmodules b/.gitmodules
index d09d81cc..78957a47 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -28,8 +28,8 @@
 	shallow = true
 [submodule "src/llvm-project"]
 	path = src/llvm-project
-	url = https://github.com/rust-lang/llvm-project.git
-	branch = rustc/20.1-2025-02-13
+	url = https://github.com/espressif/llvm-project
+	branch = xtensa_release_19.1.2
 	shallow = true
 [submodule "src/doc/embedded-book"]
 	path = src/doc/embedded-book
diff --git a/README.md b/README.md
index 61126047..da3a135a 100644
--- a/README.md
+++ b/README.md
@@ -1,56 +1,24 @@
-<div align="center">
-  <picture>
-    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/rust-lang/www.rust-lang.org/master/static/images/rust-social-wide-dark.svg">
-    <source media="(prefers-color-scheme: light)" srcset="https://raw.githubusercontent.com/rust-lang/www.rust-lang.org/master/static/images/rust-social-wide-light.svg">
-    <img alt="The Rust Programming Language: A language empowering everyone to build reliable and efficient software"
-         src="https://raw.githubusercontent.com/rust-lang/www.rust-lang.org/master/static/images/rust-social-wide-light.svg"
-         width="50%">
-  </picture>
+# The Rust Programming Language for Espressif chips
 
-[Website][Rust] | [Getting started] | [Learn] | [Documentation] | [Contributing]
-</div>
+This fork enables projects to be built for the Xtensa-based ESP32, ESP32-SXX and ESP8266 using [Espressif's llvm fork](https://github.com/espressif/llvm-project). (RiscV chips like ESP32-CXX are already supported in stock Rust.)
 
-This is the main source code repository for [Rust]. It contains the compiler,
-standard library, and documentation.
+Moreover, this fork enables Rust STD support (networking, threads, and filesystem) for all chips in the ESP32 family (Xtensa and RiscV), by optionally linking with the ESP-IDF framework.
 
-[Rust]: https://www.rust-lang.org/
-[Getting Started]: https://www.rust-lang.org/learn/get-started
-[Learn]: https://www.rust-lang.org/learn
-[Documentation]: https://www.rust-lang.org/learn#learn-use
-[Contributing]: CONTRIBUTING.md
+The [esp-rs](https://github.com/esp-rs) organization has been formed to develop runtime, pac and hal crates for the Espressif chips (bare-metal as well as ESP-IDF based).
 
-## Why Rust?
+Join in on the discussion: https://matrix.to/#/#esp-rs:matrix.org!
 
-- **Performance:** Fast and memory-efficient, suitable for critical services, embedded devices, and easily integrated with other languages.
+## Installation
 
-- **Reliability:** Our rich type system and ownership model ensure memory and thread safety, reducing bugs at compile-time.
+Please see the most up to date instructions in the [esp rust book](https://esp-rs.github.io/book/).
 
-- **Productivity:** Comprehensive documentation, a compiler committed to providing great diagnostics, and advanced tooling including package manager and build tool ([Cargo]), auto-formatter ([rustfmt]), linter ([Clippy]) and editor support ([rust-analyzer]).
+## Building from source
 
-[Cargo]: https://github.com/rust-lang/cargo
-[rustfmt]: https://github.com/rust-lang/rustfmt
-[Clippy]: https://github.com/rust-lang/rust-clippy
-[rust-analyzer]: https://github.com/rust-lang/rust-analyzer
+If you wish to build this fork from source, the instructions are almost identical to the ones upstream ([follow here](https://github.com/rust-lang/rust#installing-from-source)), however before beginning the build, run the following `./configure` command:
 
-## Quick Start
-
-Read ["Installation"] from [The Book].
-
-["Installation"]: https://doc.rust-lang.org/book/ch01-01-installation.html
-[The Book]: https://doc.rust-lang.org/book/index.html
-
-## Installing from Source
-
-If you really want to install from source (though this is not recommended), see
-[INSTALL.md](INSTALL.md).
-
-## Getting Help
-
-See https://www.rust-lang.org/community for a list of chat platforms and forums.
-
-## Contributing
-
-See [CONTRIBUTING.md](CONTRIBUTING.md).
+```
+./configure --experimental-targets=Xtensa --release-channel=nightly --enable-extended --tools=clippy,cargo,rustfmt --enable-lld
+```
 
 ## License
 
diff --git a/compiler/rustc_codegen_gcc/src/asm.rs b/compiler/rustc_codegen_gcc/src/asm.rs
index c35337ae..229c2ac4 100644
--- a/compiler/rustc_codegen_gcc/src/asm.rs
+++ b/compiler/rustc_codegen_gcc/src/asm.rs
@@ -717,6 +717,9 @@ fn reg_class_to_gcc(reg_class: InlineAsmRegClass) -> &'static str {
             | X86InlineAsmRegClass::mmx_reg
             | X86InlineAsmRegClass::tmm_reg,
         ) => unreachable!("clobber-only"),
+        InlineAsmRegClass::Xtensa(XtensaInlineAsmRegClass::reg) => "r",
+        InlineAsmRegClass::Xtensa(XtensaInlineAsmRegClass::freg) => "f",
+        InlineAsmRegClass::Xtensa(XtensaInlineAsmRegClass::breg) => "b",
         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {
             bug!("GCC backend does not support SPIR-V")
         }
@@ -822,7 +825,10 @@ fn dummy_output_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, reg: InlineAsmRegCl
         InlineAsmRegClass::CSKY(CSKYInlineAsmRegClass::freg) => cx.type_f32(),
         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {
             bug!("GCC backend does not support SPIR-V")
-        }
+        },
+        InlineAsmRegClass::Xtensa(XtensaInlineAsmRegClass::reg) => cx.type_i32(),
+        InlineAsmRegClass::Xtensa(XtensaInlineAsmRegClass::freg) => cx.type_f32(),
+        InlineAsmRegClass::Xtensa(XtensaInlineAsmRegClass::breg) => cx.type_i8(), // FIXME: should this be i1?
         InlineAsmRegClass::Err => unreachable!(),
     }
 }
@@ -1006,7 +1012,10 @@ fn modifier_to_gcc(
         InlineAsmRegClass::CSKY(_) => None,
         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {
             bug!("LLVM backend does not support SPIR-V")
-        }
+        },
+        InlineAsmRegClass::Xtensa(XtensaInlineAsmRegClass::reg) => unimplemented!(),
+        InlineAsmRegClass::Xtensa(XtensaInlineAsmRegClass::freg) => unimplemented!(),
+        InlineAsmRegClass::Xtensa(XtensaInlineAsmRegClass::breg) => unimplemented!(),
         InlineAsmRegClass::Err => unreachable!(),
     }
 }
diff --git a/compiler/rustc_codegen_llvm/src/asm.rs b/compiler/rustc_codegen_llvm/src/asm.rs
index e481b99a..c68234b3 100644
--- a/compiler/rustc_codegen_llvm/src/asm.rs
+++ b/compiler/rustc_codegen_llvm/src/asm.rs
@@ -278,6 +278,7 @@ fn codegen_inline_asm(
                 }
                 InlineAsmArch::SpirV => {}
                 InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => {}
+                InlineAsmArch::Xtensa => {}
                 InlineAsmArch::Bpf => {}
                 InlineAsmArch::Msp430 => {
                     constraints.push("~{sr}".to_string());
@@ -680,6 +681,9 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'_>>) ->
                 | X86InlineAsmRegClass::kreg0
                 | X86InlineAsmRegClass::tmm_reg,
             ) => unreachable!("clobber-only"),
+            Xtensa(XtensaInlineAsmRegClass::freg) => "f",
+            Xtensa(XtensaInlineAsmRegClass::reg) => "r",
+            Xtensa(XtensaInlineAsmRegClass::breg) => "b",
             Wasm(WasmInlineAsmRegClass::local) => "r",
             Bpf(BpfInlineAsmRegClass::reg) => "r",
             Bpf(BpfInlineAsmRegClass::wreg) => "w",
@@ -779,6 +783,7 @@ fn modifier_to_llvm(
             | X86InlineAsmRegClass::kreg0
             | X86InlineAsmRegClass::tmm_reg,
         ) => unreachable!("clobber-only"),
+        Xtensa(_) => None,
         Wasm(WasmInlineAsmRegClass::local) => None,
         Bpf(_) => None,
         Avr(AvrInlineAsmRegClass::reg_pair)
@@ -848,6 +853,9 @@ fn dummy_output_type<'ll>(cx: &CodegenCx<'ll, '_>, reg: InlineAsmRegClass) -> &'
             | X86InlineAsmRegClass::kreg0
             | X86InlineAsmRegClass::tmm_reg,
         ) => unreachable!("clobber-only"),
+        Xtensa(XtensaInlineAsmRegClass::reg) => cx.type_i32(),
+        Xtensa(XtensaInlineAsmRegClass::freg) => cx.type_f32(),
+        Xtensa(XtensaInlineAsmRegClass::breg) => cx.type_i1(),
         Wasm(WasmInlineAsmRegClass::local) => cx.type_i32(),
         Bpf(BpfInlineAsmRegClass::reg) => cx.type_i64(),
         Bpf(BpfInlineAsmRegClass::wreg) => cx.type_i32(),
diff --git a/compiler/rustc_span/src/symbol.rs b/compiler/rustc_span/src/symbol.rs
index 5c52660b..ea0a2efe 100644
--- a/compiler/rustc_span/src/symbol.rs
+++ b/compiler/rustc_span/src/symbol.rs
@@ -519,6 +519,7 @@
         async_iterator,
         async_iterator_poll_next,
         async_trait_bounds,
+        atomctl,
         atomic,
         atomic_mod,
         atomics,
@@ -566,6 +567,7 @@
         braced_empty_structs,
         branch,
         breakpoint,
+        breg,
         bridge,
         bswap,
         btreemap_contains_key,
@@ -725,6 +727,7 @@
         contracts_internals,
         contracts_requires,
         convert_identity,
+        coprocessor,
         copy,
         copy_closures,
         copy_nonoverlapping,
@@ -827,6 +830,7 @@
         derive_smart_pointer,
         destruct,
         destructuring_assignment,
+        dfpaccel,
         diagnostic,
         diagnostic_namespace,
         direct,
@@ -896,6 +900,7 @@
         ermsb_target_feature,
         exact_div,
         except,
+        exception,
         exchange_malloc,
         exclusive_range_pattern,
         exhaustive_integer_patterns,
@@ -921,6 +926,7 @@
         expr_fragment_specifier_2024,
         extended_key_value_attributes,
         extended_varargs_abi_support,
+        extendedl32r,
         extern_absolute_paths,
         extern_crate_item_prelude,
         extern_crate_self,
@@ -1033,6 +1039,7 @@
         format_macro,
         format_placeholder,
         format_unsafe_arg,
+        fp,
         freeze,
         freeze_impls,
         freg,
@@ -1101,6 +1108,7 @@
         hashset_iter_ty,
         hexagon_target_feature,
         hidden,
+        highpriinterrupts,
         hint,
         homogeneous_aggregate,
         host,
@@ -1184,6 +1192,7 @@
         integer_: "integer", // underscore to avoid clashing with the function `sym::integer` below
         integral,
         internal_features,
+        interrupt,
         into_async_iter_into_iter,
         into_future,
         into_iter,
@@ -1278,6 +1287,7 @@
         loop_break_value,
         lt,
         m68k_target_feature,
+        mac16,
         macro_at_most_once_rep,
         macro_attributes_in_derive_output,
         macro_escape,
@@ -1321,6 +1331,7 @@
         mem_variant_count,
         mem_zeroed,
         member_constraints,
+        memctl,
         memory,
         memtag,
         message,
@@ -1376,6 +1387,8 @@
         mir_unwind_unreachable,
         mir_variant,
         miri,
+        misc,
+        miscsr,
         mmx_reg,
         modifiers,
         module,
@@ -1613,6 +1626,8 @@
         prelude_import,
         preserves_flags,
         prfchw_target_feature,
+        prid,
+        primitive,
         print_macro,
         println_macro,
         proc_dash_macro: "proc-macro",
@@ -1870,8 +1885,10 @@
         rustdoc_missing_doc_code_examples,
         rustfmt,
         rvalue_static_promotion,
+        rvector,
         rwpi,
         s,
+        s32c1i,
         s390x_target_feature,
         safety,
         sanitize,
@@ -2096,10 +2113,12 @@
         thread,
         thread_local,
         thread_local_macro,
+        threadptr,
         three_way_compare,
         thumb2,
         thumb_mode: "thumb-mode",
         time,
+        timerint,
         tmm_reg,
         to_owned_method,
         to_string,
@@ -2301,6 +2320,7 @@
         where_clause_attrs,
         while_let,
         width,
+        windowed,
         windows,
         windows_subsystem,
         with_negative_coherence,
@@ -2322,8 +2342,10 @@
         x87_reg,
         x87_target_feature,
         xer,
+        xloop,
         xmm_reg,
         xop_target_feature,
+        xtensa_target_feature,
         yeet_desugar_details,
         yeet_expr,
         yes,
diff --git a/compiler/rustc_target/src/asm/mod.rs b/compiler/rustc_target/src/asm/mod.rs
index 9f791603..76ab425e 100644
--- a/compiler/rustc_target/src/asm/mod.rs
+++ b/compiler/rustc_target/src/asm/mod.rs
@@ -195,6 +195,7 @@ macro_rules! types {
 mod spirv;
 mod wasm;
 mod x86;
+mod xtensa;
 
 pub use aarch64::{AArch64InlineAsmReg, AArch64InlineAsmRegClass};
 pub use arm::{ArmInlineAsmReg, ArmInlineAsmRegClass};
@@ -213,6 +214,7 @@ macro_rules! types {
 pub use sparc::{SparcInlineAsmReg, SparcInlineAsmRegClass};
 pub use spirv::{SpirVInlineAsmReg, SpirVInlineAsmRegClass};
 pub use wasm::{WasmInlineAsmReg, WasmInlineAsmRegClass};
+pub use xtensa::{XtensaInlineAsmReg, XtensaInlineAsmRegClass};
 pub use x86::{X86InlineAsmReg, X86InlineAsmRegClass};
 
 #[derive(Copy, Clone, Encodable, Decodable, Debug, Eq, PartialEq, Hash)]
@@ -237,6 +239,7 @@ pub enum InlineAsmArch {
     SpirV,
     Wasm32,
     Wasm64,
+    Xtensa,
     Bpf,
     Avr,
     Msp430,
@@ -269,6 +272,7 @@ fn from_str(s: &str) -> Result<InlineAsmArch, ()> {
             "spirv" => Ok(Self::SpirV),
             "wasm32" => Ok(Self::Wasm32),
             "wasm64" => Ok(Self::Wasm64),
+            "xtensa" => Ok(Self::Xtensa),
             "bpf" => Ok(Self::Bpf),
             "avr" => Ok(Self::Avr),
             "msp430" => Ok(Self::Msp430),
@@ -295,6 +299,7 @@ pub enum InlineAsmReg {
     Sparc(SparcInlineAsmReg),
     SpirV(SpirVInlineAsmReg),
     Wasm(WasmInlineAsmReg),
+    Xtensa(XtensaInlineAsmReg),
     Bpf(BpfInlineAsmReg),
     Avr(AvrInlineAsmReg),
     Msp430(Msp430InlineAsmReg),
@@ -317,6 +322,7 @@ pub fn name(self) -> &'static str {
             Self::Mips(r) => r.name(),
             Self::S390x(r) => r.name(),
             Self::Sparc(r) => r.name(),
+            Self::Xtensa(r) => r.name(),
             Self::Bpf(r) => r.name(),
             Self::Avr(r) => r.name(),
             Self::Msp430(r) => r.name(),
@@ -338,6 +344,7 @@ pub fn reg_class(self) -> InlineAsmRegClass {
             Self::Mips(r) => InlineAsmRegClass::Mips(r.reg_class()),
             Self::S390x(r) => InlineAsmRegClass::S390x(r.reg_class()),
             Self::Sparc(r) => InlineAsmRegClass::Sparc(r.reg_class()),
+            Self::Xtensa(r) => InlineAsmRegClass::Xtensa(r.reg_class()),
             Self::Bpf(r) => InlineAsmRegClass::Bpf(r.reg_class()),
             Self::Avr(r) => InlineAsmRegClass::Avr(r.reg_class()),
             Self::Msp430(r) => InlineAsmRegClass::Msp430(r.reg_class()),
@@ -369,6 +376,9 @@ pub fn parse(arch: InlineAsmArch, name: Symbol) -> Result<Self, &'static str> {
             InlineAsmArch::Mips | InlineAsmArch::Mips64 => {
                 Self::Mips(MipsInlineAsmReg::parse(name)?)
             }
+            InlineAsmArch::Xtensa => {
+                Self::Xtensa(XtensaInlineAsmReg::parse(name)?)
+            }
             InlineAsmArch::S390x => Self::S390x(S390xInlineAsmReg::parse(name)?),
             InlineAsmArch::Sparc | InlineAsmArch::Sparc64 => {
                 Self::Sparc(SparcInlineAsmReg::parse(name)?)
@@ -408,6 +418,7 @@ pub fn validate(
             Self::Sparc(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),
             Self::Bpf(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),
             Self::Avr(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),
+            Self::Xtensa(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),
             Self::Msp430(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),
             Self::M68k(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),
             Self::CSKY(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),
@@ -434,6 +445,7 @@ pub fn emit(
             Self::Mips(r) => r.emit(out, arch, modifier),
             Self::S390x(r) => r.emit(out, arch, modifier),
             Self::Sparc(r) => r.emit(out, arch, modifier),
+            Self::Xtensa(r) => r.emit(out, arch, modifier),
             Self::Bpf(r) => r.emit(out, arch, modifier),
             Self::Avr(r) => r.emit(out, arch, modifier),
             Self::Msp430(r) => r.emit(out, arch, modifier),
@@ -455,6 +467,7 @@ pub fn overlapping_regs(self, mut cb: impl FnMut(InlineAsmReg)) {
             Self::Mips(_) => cb(self),
             Self::S390x(r) => r.overlapping_regs(|r| cb(Self::S390x(r))),
             Self::Sparc(_) => cb(self),
+            Self::Xtensa(_) => cb(self),
             Self::Bpf(r) => r.overlapping_regs(|r| cb(Self::Bpf(r))),
             Self::Avr(r) => r.overlapping_regs(|r| cb(Self::Avr(r))),
             Self::Msp430(_) => cb(self),
@@ -481,6 +494,7 @@ pub enum InlineAsmRegClass {
     Sparc(SparcInlineAsmRegClass),
     SpirV(SpirVInlineAsmRegClass),
     Wasm(WasmInlineAsmRegClass),
+    Xtensa(XtensaInlineAsmRegClass),
     Bpf(BpfInlineAsmRegClass),
     Avr(AvrInlineAsmRegClass),
     Msp430(Msp430InlineAsmRegClass),
@@ -506,6 +520,7 @@ pub fn name(self) -> Symbol {
             Self::Sparc(r) => r.name(),
             Self::SpirV(r) => r.name(),
             Self::Wasm(r) => r.name(),
+            Self::Xtensa(r) => r.name(),
             Self::Bpf(r) => r.name(),
             Self::Avr(r) => r.name(),
             Self::Msp430(r) => r.name(),
@@ -533,6 +548,7 @@ pub fn suggest_class(self, arch: InlineAsmArch, ty: InlineAsmType) -> Option<Sel
             Self::Sparc(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Sparc),
             Self::SpirV(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::SpirV),
             Self::Wasm(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Wasm),
+            Self::Xtensa(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Xtensa),
             Self::Bpf(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Bpf),
             Self::Avr(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Avr),
             Self::Msp430(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Msp430),
@@ -563,6 +579,7 @@ pub fn suggest_modifier(self, arch: InlineAsmArch, ty: InlineAsmType) -> Option<
             Self::Sparc(r) => r.suggest_modifier(arch, ty),
             Self::SpirV(r) => r.suggest_modifier(arch, ty),
             Self::Wasm(r) => r.suggest_modifier(arch, ty),
+            Self::Xtensa(r) => r.suggest_modifier(arch, ty),
             Self::Bpf(r) => r.suggest_modifier(arch, ty),
             Self::Avr(r) => r.suggest_modifier(arch, ty),
             Self::Msp430(r) => r.suggest_modifier(arch, ty),
@@ -593,6 +610,7 @@ pub fn default_modifier(self, arch: InlineAsmArch) -> Option<ModifierInfo> {
             Self::Sparc(r) => r.default_modifier(arch),
             Self::SpirV(r) => r.default_modifier(arch),
             Self::Wasm(r) => r.default_modifier(arch),
+            Self::Xtensa(r) => r.default_modifier(arch),
             Self::Bpf(r) => r.default_modifier(arch),
             Self::Avr(r) => r.default_modifier(arch),
             Self::Msp430(r) => r.default_modifier(arch),
@@ -626,6 +644,7 @@ pub fn supported_types(
             Self::Sparc(r) => r.supported_types(arch),
             Self::SpirV(r) => r.supported_types(arch),
             Self::Wasm(r) => r.supported_types(arch),
+            Self::Xtensa(r) => r.supported_types(arch),
             Self::Bpf(r) => r.supported_types(arch),
             Self::Avr(r) => r.supported_types(arch),
             Self::Msp430(r) => r.supported_types(arch),
@@ -666,6 +685,7 @@ pub fn parse(arch: InlineAsmArch, name: Symbol) -> Result<Self, &'static [rustc_
             }
             InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmRegClass::parse(name)?),
             InlineAsmArch::Avr => Self::Avr(AvrInlineAsmRegClass::parse(name)?),
+            InlineAsmArch::Xtensa => Self::Xtensa(XtensaInlineAsmRegClass::parse(name)?),
             InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmRegClass::parse(name)?),
             InlineAsmArch::M68k => Self::M68k(M68kInlineAsmRegClass::parse(name)?),
             InlineAsmArch::CSKY => Self::CSKY(CSKYInlineAsmRegClass::parse(name)?),
@@ -689,6 +709,7 @@ pub fn valid_modifiers(self, arch: InlineAsmArch) -> &'static [char] {
             Self::Sparc(r) => r.valid_modifiers(arch),
             Self::SpirV(r) => r.valid_modifiers(arch),
             Self::Wasm(r) => r.valid_modifiers(arch),
+            Self::Xtensa(r) => r.valid_modifiers(arch),
             Self::Bpf(r) => r.valid_modifiers(arch),
             Self::Avr(r) => r.valid_modifiers(arch),
             Self::Msp430(r) => r.valid_modifiers(arch),
@@ -736,6 +757,7 @@ fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 /// Set of types which can be used with a particular register class.
 #[derive(Copy, Clone, Debug, Eq, PartialEq)]
 pub enum InlineAsmType {
+    I1,
     I8,
     I16,
     I32,
@@ -763,6 +785,7 @@ pub fn is_integer(self) -> bool {
 
     pub fn size(self) -> Size {
         Size::from_bytes(match self {
+            Self::I1 => return Size::from_bits(1),
             Self::I8 => 1,
             Self::I16 => 2,
             Self::I32 => 4,
@@ -788,6 +811,7 @@ pub fn size(self) -> Size {
 impl fmt::Display for InlineAsmType {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         match *self {
+            Self::I1 => f.write_str("i1"),
             Self::I8 => f.write_str("i8"),
             Self::I16 => f.write_str("i16"),
             Self::I32 => f.write_str("i32"),
@@ -890,6 +914,11 @@ pub fn allocatable_registers(
             wasm::fill_reg_map(arch, reloc_model, target_features, target, &mut map);
             map
         }
+        InlineAsmArch::Xtensa => {
+            let mut map = xtensa::regclass_map();
+            xtensa::fill_reg_map(arch, reloc_model, target_features, target, &mut map);
+            map
+        }
         InlineAsmArch::Bpf => {
             let mut map = bpf::regclass_map();
             bpf::fill_reg_map(arch, reloc_model, target_features, target, &mut map);
diff --git a/compiler/rustc_target/src/asm/xtensa.rs b/compiler/rustc_target/src/asm/xtensa.rs
new file mode 100644
index 00000000..6fd9aed0
--- /dev/null
+++ b/compiler/rustc_target/src/asm/xtensa.rs
@@ -0,0 +1,293 @@
+use super::{InlineAsmArch, InlineAsmType, ModifierInfo};
+use crate::spec::{Target, RelocModel};
+use rustc_data_structures::fx::FxIndexSet;
+use rustc_span::{sym, Symbol};
+use std::fmt;
+
+def_reg_class! {
+    Xtensa XtensaInlineAsmRegClass {
+        reg,
+        freg,
+        breg,
+    }
+}
+
+impl XtensaInlineAsmRegClass {
+    pub fn valid_modifiers(self, _arch: super::InlineAsmArch) -> &'static [char] {
+        &[]
+    }
+
+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {
+        None
+    }
+
+    pub fn suggest_modifier(
+        self,
+        _arch: InlineAsmArch,
+        _ty: InlineAsmType,
+    ) -> Option<ModifierInfo> {
+        None
+    }
+
+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<ModifierInfo> {
+        None
+    }
+
+    pub fn supported_types(
+        self,
+        _arch: InlineAsmArch,
+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {
+        match self {
+            Self::reg => types! { _: I8, I16, I32; },
+            Self::breg => types! { bool: I1; },
+            Self::freg => types! { fp: F32; dfpaccel: F64; },
+        }
+    }
+}
+
+// Xtensa has lots of features - macro to reduce boiler plate
+macro_rules! feature {
+    ($fnname:ident, $feature:expr) => {
+        fn $fnname(
+            _arch: InlineAsmArch,
+            _reloc_model: RelocModel,
+            target_features: &FxIndexSet<Symbol>,
+            _target: &Target,
+            _is_clobber: bool,
+        ) -> Result<(), &'static str> {
+            if target_features.contains(&$feature) {
+                Ok(())
+            } else {
+                Err(concat!("target does not support ", stringify!($feature), " registers"))
+            }
+        }
+    };
+}
+
+feature!(has_fp, sym::fp);
+feature!(has_dfpaccel, sym::dfpaccel);
+feature!(has_bool, sym::bool);
+feature!(has_xloop, sym::xloop);
+feature!(has_extendedl32r, sym::extendedl32r);
+feature!(has_s32c1i, sym::s32c1i);
+feature!(has_mac16, sym::mac16);
+feature!(has_windowed, sym::windowed);
+feature!(has_debug, sym::debug);
+feature!(has_memctl, sym::memctl);
+feature!(has_atomctl, sym::atomctl);
+feature!(has_exception, sym::exception);
+feature!(has_highpriinterrupts, sym::highpriinterrupts);
+feature!(has_coprocessor, sym::coprocessor);
+feature!(has_rvector, sym::rvector);
+feature!(has_timerint, sym::timerint);
+feature!(has_interrupt, sym::interrupt);
+feature!(has_prid, sym::prid);
+feature!(has_miscsr, sym::miscsr);
+feature!(has_threadptr, sym::threadptr);
+
+fn has_expstate(
+    _arch: InlineAsmArch,
+    _reloc_model: RelocModel,
+    _target_features: &FxIndexSet<Symbol>,
+    target: &Target,
+    _is_clobber: bool,
+) -> Result<(), &'static str> {
+    match target.cpu.as_ref() {
+        "esp32" => Ok(()),
+        _ => Err("target does not support expstate registers")
+    }
+}
+fn has_gpio_out(
+    _arch: InlineAsmArch,
+    _reloc_model: RelocModel,
+    _target_features: &FxIndexSet<Symbol>,
+    target: &Target,
+    _is_clobber: bool,
+) -> Result<(), &'static str> {
+    match target.cpu.as_ref() {
+        "esp32-s2" => Ok(()),
+        _ => Err("target does not support gpio_out registers")
+    }
+}
+
+// FIXME sometimes there isn't a frame pointer at all?
+fn frame_pointer_is_a7(
+    _arch: InlineAsmArch,
+    _reloc_model: RelocModel,
+    target_features: &FxIndexSet<Symbol>,
+    _target: &Target,
+    _is_clobber: bool,
+) -> bool {
+    target_features.contains(&sym::windowed)
+}
+
+fn frame_pointer_a7(
+    arch: InlineAsmArch,
+    reloc_model: RelocModel,
+    target_features: &FxIndexSet<Symbol>,
+    target: &Target,
+    is_clobber: bool,
+) -> Result<(), &'static str> {
+    if frame_pointer_is_a7(arch, reloc_model, target_features, target, is_clobber) {
+        Err("the frame pointer (a7) cannot be used as an operand for inline asm")
+    } else {
+        Ok(())
+    }
+}
+
+fn frame_pointer_a15(
+    arch: InlineAsmArch,
+    reloc_model: RelocModel,
+    target_features: &FxIndexSet<Symbol>,
+    target: &Target,
+    is_clobber: bool,
+) -> Result<(), &'static str> {
+    if !frame_pointer_is_a7(arch, reloc_model, target_features, target, is_clobber) {
+        Err("the frame pointer (a15) cannot be used as an operand for inline asm")
+    } else {
+        Ok(())
+    }
+}
+
+def_regs! {
+    Xtensa XtensaInlineAsmReg XtensaInlineAsmRegClass {
+        a2: reg = ["a2"],
+        a3: reg = ["a3"],
+        a4: reg = ["a4"],
+        a5: reg = ["a5"],
+        a6: reg = ["a6"],
+        a7: reg = ["a7"] % frame_pointer_a7,
+        a8: reg = ["a8"],
+        a9: reg = ["a9"],
+        a10: reg = ["a10"],
+        a11: reg = ["a11"],
+        a12: reg = ["a12"],
+        a13: reg = ["a13"],
+        a14: reg = ["a14"],
+        a15: reg = ["a15"] % frame_pointer_a15,
+        sar: reg = ["sar"],
+        configid0: reg = ["configid0"], 
+        configid1: reg = ["configid1"],
+        lbeg: reg = ["lbeg"] % has_xloop,
+        lend: reg = ["lend"] % has_xloop,
+        lcount: reg = ["lcount"] % has_xloop,
+        litbase: reg = ["litbase"] % has_extendedl32r,
+        scompare1: reg = ["scompare1"] % has_s32c1i,
+        acclo: reg = ["acclo"] % has_mac16,
+        acchi: reg = ["acchi"] % has_mac16,
+        m0: reg = ["m0"] % has_mac16,
+        m1: reg = ["m1"] % has_mac16,
+        m2: reg = ["m2"] % has_mac16,
+        m3: reg = ["m3"] % has_mac16,
+        windowbase: reg = ["windowbase"] % has_windowed,
+        windowstart: reg = ["windowstart"] % has_windowed,
+        ddr: reg = ["ddr"] % has_debug,
+        ibreakenable: reg = ["ibreakenable"] % has_debug,
+        ibreaka0: reg = ["ibreaka0"] % has_debug,
+        ibreaka1: reg = ["ibreaka1"] % has_debug,
+        dbreaka0: reg = ["dbreaka0"] % has_debug,
+        dbreaka1: reg = ["dbreaka1"] % has_debug,
+        dbreakc0: reg = ["dbreakc0"] % has_debug,
+        dbreakc1: reg = ["dbreakc1"] % has_debug,
+        icount: reg = ["icount"] % has_debug,
+        icountlevel: reg = ["icountlevel"] % has_debug,
+        debugcause: reg = ["debugcause"] % has_debug,
+        memctl: reg = ["memctl"] % has_memctl,
+        atomctl: reg = ["atomctl"] % has_atomctl,
+        ps: reg = ["ps"] % has_exception,
+        epc1: reg = ["epc1"] % has_exception,
+        epc2: reg = ["epc2"] % has_highpriinterrupts,
+        epc3: reg = ["epc3"] % has_highpriinterrupts,
+        epc4: reg = ["epc4"] % has_highpriinterrupts,
+        epc5: reg = ["epc5"] % has_highpriinterrupts,
+        epc6: reg = ["epc6"] % has_highpriinterrupts,
+        epc7: reg = ["epc7"] % has_highpriinterrupts,
+        depc: reg = ["depc"] % has_exception,
+        eps2: reg = ["eps2"] % has_highpriinterrupts,
+        eps3: reg = ["eps3"] % has_highpriinterrupts,
+        eps4: reg = ["eps4"] % has_highpriinterrupts,
+        eps5: reg = ["eps5"] % has_highpriinterrupts,
+        eps6: reg = ["eps6"] % has_highpriinterrupts,
+        eps7: reg = ["eps7"] % has_highpriinterrupts,
+        excsave1: reg = ["excsave1"] % has_exception,
+        excsave2: reg = ["excsave2"] % has_highpriinterrupts,
+        excsave3: reg = ["excsave3"] % has_highpriinterrupts,
+        excsave4: reg = ["excsave4"] % has_highpriinterrupts,
+        excsave5: reg = ["excsave5"] % has_highpriinterrupts,
+        excsave6: reg = ["excsave6"] % has_highpriinterrupts,
+        excsave7: reg = ["excsave7"] % has_highpriinterrupts,
+        exccause: reg = ["exccause"] % has_exception,
+        excvaddr: reg = ["excvaddr"] % has_exception,
+        cpenable: reg = ["cpenable"] % has_coprocessor,
+        vecbase: reg = ["vecbase"] % has_rvector,
+        interrupt: reg = ["interrupt"] % has_interrupt,
+        intclear: reg = ["intclear"] % has_interrupt,
+        intenable: reg = ["intenable"] % has_interrupt,
+        prid: reg = ["prid"] % has_prid,
+        ccount: reg = ["ccount"] % has_timerint,
+        ccompare0: reg = ["ccompare0"] % has_timerint,
+        ccompare1: reg = ["ccompare1"] % has_timerint,
+        ccompare2: reg = ["ccompare2"] % has_timerint,
+        misc0: reg = ["misc0"] % has_miscsr,
+        misc1: reg = ["misc1"] % has_miscsr,
+        misc2: reg = ["misc2"] % has_miscsr,
+        misc3: reg = ["misc3"] % has_miscsr,
+        threadptr: reg = ["threadptr"] % has_threadptr,
+        fcr: reg = ["fcr"] % has_dfpaccel,
+        fsr: reg = ["fsr"] % has_dfpaccel,
+        f64r_lo: reg = ["f64r_lo"] % has_dfpaccel,
+        f64r_hi: reg = ["f64r_hi"] % has_dfpaccel,
+        f64s: reg = ["f64s"] % has_dfpaccel,
+        f0: freg = ["f0"] % has_fp,
+        f1: freg = ["f1"] % has_fp,
+        f2: freg = ["f2"] % has_fp,
+        f3: freg = ["f3"] % has_fp,
+        f4: freg = ["f4"] % has_fp,
+        f5: freg = ["f5"] % has_fp,
+        f6: freg = ["f6"] % has_fp,
+        f7: freg = ["f7"] % has_fp,
+        f8: freg = ["f8"] % has_fp,
+        f9: freg = ["f9"] % has_fp,
+        f10: freg = ["f10"] % has_fp,
+        f11: freg = ["f11"] % has_fp,
+        f12: freg = ["f12"] % has_fp,
+        f13: freg = ["f13"] % has_fp,
+        f14: freg = ["f14"] % has_fp,
+        f15: freg = ["f15"] % has_fp,
+        br: reg = ["br"] % has_bool,
+        b0: breg = ["b0"] % has_bool,
+        b1: breg = ["b1"] % has_bool,
+        b2: breg = ["b2"] % has_bool,
+        b3: breg = ["b3"] % has_bool,
+        b4: breg = ["b4"] % has_bool,
+        b5: breg = ["b5"] % has_bool,
+        b6: breg = ["b6"] % has_bool,
+        b7: breg = ["b7"] % has_bool,
+        b8: breg = ["b8"] % has_bool,
+        b9: breg = ["b9"] % has_bool,
+        b10: breg = ["b10"] % has_bool,
+        b11: breg = ["b11"] % has_bool,
+        b12: breg = ["b12"] % has_bool,
+        b13: breg = ["b13"] % has_bool,
+        b14: breg = ["b14"] % has_bool,
+        b15: breg = ["b15"] % has_bool,
+
+        // Custom TIE extensions - https://en.wikipedia.org/wiki/Tensilica_Instruction_Extension
+        gpio_out: reg = ["gpio_out"] % has_gpio_out,
+        expstate: reg = ["expstate"] % has_expstate,
+        
+        #error = ["a0"] => "a0 is used internally by LLVM and cannot be used as an operand for inline asm",
+        #error = ["sp", "a1"] => "sp is used internally by LLVM and cannot be used as an operand for inline asm",
+    }
+}
+
+impl XtensaInlineAsmReg {
+    pub fn emit(
+        self,
+        out: &mut dyn fmt::Write,
+        _arch: InlineAsmArch,
+        _modifier: Option<char>,
+    ) -> fmt::Result {
+        out.write_str(self.name())
+    }
+}
diff --git a/compiler/rustc_target/src/spec/mod.rs b/compiler/rustc_target/src/spec/mod.rs
index 303be54a..e01b3f8d 100644
--- a/compiler/rustc_target/src/spec/mod.rs
+++ b/compiler/rustc_target/src/spec/mod.rs
@@ -2003,6 +2003,7 @@ fn $module() {
     ("xtensa-esp32s2-espidf", xtensa_esp32s2_espidf),
     ("xtensa-esp32s3-none-elf", xtensa_esp32s3_none_elf),
     ("xtensa-esp32s3-espidf", xtensa_esp32s3_espidf),
+    ("xtensa-esp8266-none-elf", xtensa_esp8266_none_elf),
 
     ("i686-wrs-vxworks", i686_wrs_vxworks),
     ("x86_64-wrs-vxworks", x86_64_wrs_vxworks),
@@ -3605,6 +3606,7 @@ pub fn object_architecture(
             "avr" => (Architecture::Avr, None),
             "msp430" => (Architecture::Msp430, None),
             "hexagon" => (Architecture::Hexagon, None),
+            "xtensa" => (Architecture::Xtensa, None),
             "bpf" => (Architecture::Bpf, None),
             "loongarch64" => (Architecture::LoongArch64, None),
             "csky" => (Architecture::Csky, None),
diff --git a/compiler/rustc_target/src/spec/targets/xtensa_esp8266_none_elf.rs b/compiler/rustc_target/src/spec/targets/xtensa_esp8266_none_elf.rs
new file mode 100644
index 00000000..557970f7
--- /dev/null
+++ b/compiler/rustc_target/src/spec/targets/xtensa_esp8266_none_elf.rs
@@ -0,0 +1,24 @@
+use crate::spec::{base::xtensa, Target, TargetOptions};
+
+pub(crate) fn target() -> Target {
+    Target {
+        llvm_target: "xtensa-none-elf".into(),
+        pointer_width: 32,
+        data_layout: "e-m:e-p:32:32-v1:8:8-i64:64-i128:128-n32".into(),
+        arch: "xtensa".into(),
+        metadata: crate::spec::TargetMetadata {
+            description: Some("Xtensa ESP8266".into()),
+            tier: Some(3),
+            host_tools: Some(false),
+            std: Some(false),
+        },
+
+        options: TargetOptions {
+            cpu: "esp8266".into(),
+            linker: Some("xtensa-lx106-elf-gcc".into()),
+            max_atomic_width: Some(32),
+            features: "+forced-atomics".into(),
+            ..xtensa::opts()
+        },
+    }
+}
\ No newline at end of file
diff --git a/compiler/rustc_target/src/target_features.rs b/compiler/rustc_target/src/target_features.rs
index 5a21925b..28fd81d8 100644
--- a/compiler/rustc_target/src/target_features.rs
+++ b/compiler/rustc_target/src/target_features.rs
@@ -758,6 +758,36 @@ pub fn toggle_allowed(&self) -> Result<(), &'static str> {
     // tidy-alphabetical-end
 ];
 
+// TODO fill out implied features
+const XTENSA_FEATURES: &[(&str, Stability, ImpliedFeatures)] = &[
+    ("fp", Unstable(sym::xtensa_target_feature), &[]),
+    ("windowed", Unstable(sym::xtensa_target_feature), &[]),
+    ("bool", Unstable(sym::xtensa_target_feature), &[]),
+    ("loop", Unstable(sym::xtensa_target_feature), &[]),
+    ("sext", Unstable(sym::xtensa_target_feature), &[]),
+    ("nsa", Unstable(sym::xtensa_target_feature), &[]),
+    ("mul32", Unstable(sym::xtensa_target_feature), &[]),
+    ("mul32high", Unstable(sym::xtensa_target_feature), &[]),
+    ("div32", Unstable(sym::xtensa_target_feature), &[]),
+    ("mac16", Unstable(sym::xtensa_target_feature), &[]),
+    ("dfpaccel", Unstable(sym::xtensa_target_feature), &[]),
+    ("s32c1i", Unstable(sym::xtensa_target_feature), &[]),
+    ("threadptr", Unstable(sym::xtensa_target_feature), &[]),
+    ("extendedl32r", Unstable(sym::xtensa_target_feature), &[]),
+    ("atomctl", Unstable(sym::xtensa_target_feature), &[]),
+    ("memctl", Unstable(sym::xtensa_target_feature), &[]),
+    ("debug", Unstable(sym::xtensa_target_feature), &[]),
+    ("exception", Unstable(sym::xtensa_target_feature), &[]),
+    ("highpriinterrupts", Unstable(sym::xtensa_target_feature), &[]),
+    ("coprocessor", Unstable(sym::xtensa_target_feature), &[]),
+    ("interrupt", Unstable(sym::xtensa_target_feature), &[]),
+    ("rvector", Unstable(sym::xtensa_target_feature), &[]),
+    ("timerint", Unstable(sym::xtensa_target_feature), &[]),
+    ("prid", Unstable(sym::xtensa_target_feature), &[]),
+    ("regprotect", Unstable(sym::xtensa_target_feature), &[]),
+    ("miscsr", Unstable(sym::xtensa_target_feature), &[]),
+];
+
 /// When rustdoc is running, provide a list of all known features so that all their respective
 /// primitives may be documented.
 ///
@@ -773,6 +803,7 @@ pub fn all_rust_features() -> impl Iterator<Item = (&'static str, Stability)> {
         .chain(RISCV_FEATURES.iter())
         .chain(WASM_FEATURES.iter())
         .chain(BPF_FEATURES.iter())
+        .chain(XTENSA_FEATURES.iter())
         .chain(CSKY_FEATURES)
         .chain(LOONGARCH_FEATURES)
         .chain(IBMZ_FEATURES)
@@ -844,6 +875,7 @@ pub fn rust_target_features(&self) -> &'static [(&'static str, Stability, Implie
             "s390x" => IBMZ_FEATURES,
             "sparc" | "sparc64" => SPARC_FEATURES,
             "m68k" => M68K_FEATURES,
+            "xtensa" => XTENSA_FEATURES,
             _ => &[],
         }
     }
diff --git a/src/llvm-project b/src/llvm-project
index c1118fdb..0b10ac7a 160000
--- a/src/llvm-project
+++ b/src/llvm-project
@@ -1 +1 @@
-Subproject commit c1118fdbb3024157df7f4cfe765f2b0b4339e8a2
+Subproject commit 0b10ac7aa166e0c040668776c10c72aaa7595d80
diff --git a/tests/assembly/asm/xtensa-types.rs b/tests/assembly/asm/xtensa-types.rs
new file mode 100644
index 00000000..74908bc0
--- /dev/null
+++ b/tests/assembly/asm/xtensa-types.rs
@@ -0,0 +1,139 @@
+//@ assembly-output: emit-asm
+//@ compile-flags: --target xtensa-esp32-none-elf
+//@ needs-llvm-components: xtensa
+
+#![feature(no_core, lang_items, rustc_attrs, repr_simd, asm_experimental_arch)]
+#![crate_type = "rlib"]
+#![no_core]
+#![allow(asm_sub_register, non_camel_case_types)]
+
+#[rustc_builtin_macro]
+macro_rules! asm {
+    () => {};
+}
+#[rustc_builtin_macro]
+macro_rules! concat {
+    () => {};
+}
+#[rustc_builtin_macro]
+macro_rules! stringify {
+    () => {};
+}
+
+#[lang = "sized"]
+trait Sized {}
+#[lang = "copy"]
+trait Copy {}
+
+type ptr = *const i32;
+
+impl Copy for i8 {}
+impl Copy for i16 {}
+impl Copy for i32 {}
+impl Copy for f32 {}
+impl Copy for f64 {}
+impl Copy for ptr {}
+
+extern "C" {
+    fn extern_func();
+}
+
+// Hack to avoid function merging
+extern "Rust" {
+    fn dont_merge(s: &str);
+}
+
+// CHECK-LABEL: sym_fn:
+// CHECK: #APP
+// CHECK: call4 extern_func
+// CHECK: #NO_APP
+#[no_mangle]
+pub unsafe fn sym_fn() {
+    asm!("call4 {}", sym extern_func);
+}
+
+macro_rules! check_general_reg {
+    ($func:ident $ty:ident $class:ident $mov:literal) => {
+        #[no_mangle]
+        pub unsafe fn $func(x: $ty) -> $ty {
+            dont_merge(stringify!($func));
+
+            let y;
+            asm!(concat!($mov, " {}, {}"), out($class) y, in($class) x);
+            y
+        }
+    };
+}
+
+// CHECK-LABEL: reg_i8:
+// CHECK: #APP
+// CHECK: or a{{[0-9]+}}, a{{[0-9]+}}, a{{[0-9]+}}
+// CHECK: #NO_APP
+check_general_reg!(reg_i8 i8 reg "mov");
+
+// CHECK-LABEL: reg_i16:
+// CHECK: #APP
+// CHECK: or a{{[0-9]+}}, a{{[0-9]+}}, a{{[0-9]+}}
+// CHECK: #NO_APP
+check_general_reg!(reg_i16 i16 reg "mov");
+
+// CHECK-LABEL: reg_i32:
+// CHECK: #APP
+// CHECK: or a{{[0-9]+}}, a{{[0-9]+}}, a{{[0-9]+}}
+// CHECK: #NO_APP
+check_general_reg!(reg_i32 i32 reg "mov");
+
+// CHECK-LABEL: reg_ptr:
+// CHECK: #APP
+// CHECK: or a{{[0-9]+}}, a{{[0-9]+}}, a{{[0-9]+}}
+// CHECK: #NO_APP
+check_general_reg!(reg_ptr ptr reg "mov");
+
+// CHECK-LABEL: freg_f32:
+// CHECK: #APP
+// CHECK: mov.s f{{[0-9]+}}, f{{[0-9]+}}
+// CHECK: #NO_APP
+check_general_reg!(freg_f32 f32 freg "mov.s");
+
+macro_rules! check_explicit_reg {
+    ($func:ident $ty:ident $reg:tt $mov:literal) => {
+        #[no_mangle]
+        pub unsafe fn $func(x: $ty) -> $ty {
+            dont_merge(stringify!($func));
+
+            let y;
+            asm!(concat!($mov, " ", $reg, ", ", $reg), lateout($reg) y, in($reg) x);
+            y
+        }
+    };
+}
+
+// CHECK-LABEL: a5_i8:
+// CHECK: #APP
+// CHECK: or a5, a5, a5
+// CHECK: #NO_APP
+check_explicit_reg!(a5_i8 i8 "a5" "mov");
+
+// CHECK-LABEL: a5_i16:
+// CHECK: #APP
+// CHECK: or a5, a5, a5
+// CHECK: #NO_APP
+check_explicit_reg!(a5_i16 i16 "a5" "mov");
+
+// CHECK-LABEL: a5_i32:
+// CHECK: #APP
+// CHECK: or a5, a5, a5
+// CHECK: #NO_APP
+check_explicit_reg!(a5_i32 i32 "a5" "mov");
+
+// CHECK-LABEL: a5_ptr:
+// CHECK: #APP
+// CHECK: or a5, a5, a5
+// CHECK: #NO_APP
+check_explicit_reg!(a5_ptr ptr "a5" "mov");
+
+// CHECK-LABEL: f0_f32:
+// CHECK: #APP
+// CHECK: mov.s f0, f0
+// CHECK: #NO_APP
+check_explicit_reg!(f0_f32 f32 "f0" "mov.s");
